了解です！
では、\*\*繰り返し二乗法（Binary Exponentiation）\*\*を図と数式を交えて、`a = 3`, `b = 13` の例で丁寧に解説します。

---

## 🧮 目的：

> `a^b % mod` を高速に求めたい。
> 例：`3^13 % 1000000007`

---

## ✅ ステップ1：bを2進数に変換

```
b = 13 = 0b1101
        ↑↑↑↑
        8 4 0 1 のビット（下から見る）
```

つまり

```
3^13 = 3^8 × 3^4 × 3^1  （3^2 は使わない）  
     = (3^1) × (3^4) × (3^8)
```

---

## 🔁 処理の様子を表にまとめる

| b (10進) | b (2進) | bの最下位ビット | aの値（累乗）    | 操作内容            | result 更新                   |
| ------- | ------ | -------- | ---------- | --------------- | --------------------------- |
| 13      | 1101   | 1（奇数）    | 3          | result \*= 3    | result = 3                  |
| 6       | 0110   | 0（偶数）    | 3² = 9     | スキップ            | result unchanged            |
| 3       | 0011   | 1（奇数）    | 9² = 81    | result \*= 81   | result = 3×81 = 243         |
| 1       | 0001   | 1（奇数）    | 81² = 6561 | result \*= 6561 | result = 243×6561 = 1594323 |
| 0       | 0000   | 終了       | -          | -               | -                           |

※ 途中で `mod` を取ると `result %= 1000000007` になります。

---

## ✍️ 数式で書くと

```
result = 1
if b のビットが1のときだけ:
  result = (result * a^(2^k)) % mod
```

この `a^(2^k)` は `a = a * a % mod` を繰り返すことで得られます。

---

## 🧠 メリット

* 時間計算量は **O(log b)**（bのビット数だけループ）
* 普通に a を b 回かけると O(b) になるので、効率が大幅アップ！

---

## ✅ 実装と結びつけると

```ts
while (b > 0n) {
  if (b % 2n === 1n) {
    result = (result * a) % mod; // ビットが1なら結果にかける
  }
  a = (a * a) % mod; // 次の2乗を用意
  b = b / 2n;        // ビットを1つ右にずらす
}
```

---

図やアニメーションが必要であれば、追加でビジュアル化もできます！
